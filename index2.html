<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flashcard</title>
 <link rel="stylesheet" href="main.css">
</head>

<body>
  <h1>ğŸ’¡ Tá»« vá»±ng má»—i ngÃ y</h1>

  <div class="progress-bar">
    <div class="progress-fill" id="progressFill"></div>
  </div>

  <div class="card-container">
    <div class="card" id="card" ontouchstart="handleTouchStart(event)" ontouchmove="handleTouchMove(event)" ontouchend="handleTouchEnd(event)" onclick="flipCard(event)">
      <div class="card-controls">
        <button class="control-btn" id="learnBtn" onclick="toggleLearned(event)" title="ÄÃ¡nh dáº¥u Ä‘Ã£ há»c">â—‹</button>
        <button class="control-btn copy" onclick="copyWord(event)" title="Sao chÃ©p tá»«">ğŸ“‹</button>
        <button class="control-btn sound" onclick="playPronunciation(event)" title="PhÃ¡t Ã¢m">ğŸ”Š</button>
      </div>
      <div class="word-line">
        <div class="word" id="word">Äang táº£i...</div>
        <div class="pronunciation" id="pronunciation"></div>
        <div class="word-type" id="wordType"></div>
      </div>
      <div class="meaning" id="meaning"></div>
      <div class="example" id="example"></div>
    </div>
  </div>

  <div class="status" id="status"></div>
  <div class="api-status" id="apiStatus" style="display: none;"></div>

  <script>
    let vocabulary = [];
    let currentIndex = 0;
    let flipped = false;
    let currentAudio = null;
    let wordDataCache = {};

    // Touch/swipe variables
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let isDragging = false;
    let cardEl = null;

    const wordEl = document.getElementById("word");
    const pronunciationEl = document.getElementById("pronunciation");
    const meaningEl = document.getElementById("meaning");
    const exampleEl = document.getElementById("example");
    const statusEl = document.getElementById("status");
    const wordTypeEl = document.getElementById("wordType");
    const learnBtnEl = document.getElementById("learnBtn");
    const progressFillEl = document.getElementById("progressFill");
    const apiStatusEl = document.getElementById("apiStatus");

    // Mapping cho tá»« loáº¡i
    const partOfSpeechMap = {
      'noun': { short: 'n', name: 'Danh tá»«', class: 'n' },
      'verb': { short: 'v', name: 'Äá»™ng tá»«', class: 'v' },
      'adjective': { short: 'adj', name: 'TÃ­nh tá»«', class: 'adj' },
      'adverb': { short: 'adv', name: 'Tráº¡ng tá»«', class: 'adv' },
      'preposition': { short: 'prep', name: 'Giá»›i tá»«', class: 'prep' },
      'conjunction': { short: 'conj', name: 'LiÃªn tá»«', class: 'conj' },
      'interjection': { short: 'interj', name: 'ThÃ¡n tá»«', class: 'interj' },
      'pronoun': { short: 'pron', name: 'Äáº¡i tá»«', class: 'pron' },
      'determiner': { short: 'det', name: 'Tá»« háº¡n Ä‘á»‹nh', class: 'det' },
      'exclamation': { short: 'interj', name: 'ThÃ¡n tá»«', class: 'interj' }
    };

    // HÃ m hiá»ƒn thá»‹ tráº¡ng thÃ¡i API
    function showApiStatus(message, type) {
      apiStatusEl.textContent = message;
      apiStatusEl.className = `api-status ${type}`;
      apiStatusEl.style.display = 'block';
      
      setTimeout(() => {
        apiStatusEl.style.display = 'none';
      }, 3000);
    }

    // Enhanced word data vá»›i phiÃªn Ã¢m cÃ³ sáºµn
    const enhancedWordData = {
      'intend': { pronunciation: '/ÉªnËˆtend/', partOfSpeech: 'verb' },
      'serendipity': { pronunciation: '/ËŒsÉ›rÉ™nËˆdÉªpÉªti/', partOfSpeech: 'noun' },
      'ephemeral': { pronunciation: '/ÉªËˆfÉ›mÉ™rÉ™l/', partOfSpeech: 'adjective' },
      'ubiquitous': { pronunciation: '/juËËˆbÉªkwÉªtÉ™s/', partOfSpeech: 'adjective' },
      'mellifluous': { pronunciation: '/mÉ™ËˆlÉªfluÉ™s/', partOfSpeech: 'adjective' },
      'quintessential': { pronunciation: '/ËŒkwÉªntÉªËˆsÉ›nÊƒÉ™l/', partOfSpeech: 'adjective' },
      'quickly': { pronunciation: '/ËˆkwÉªkli/', partOfSpeech: 'adverb' },
      'beautiful': { pronunciation: '/ËˆbjuËtÉªfÉ™l/', partOfSpeech: 'adjective' },
      'adventure': { pronunciation: '/É™dËˆventÊƒÉ™r/', partOfSpeech: 'noun' },
      'mysterious': { pronunciation: '/mÉªËˆstÉªÉ™riÉ™s/', partOfSpeech: 'adjective' },
      'important': { pronunciation: '/ÉªmËˆpÉ”ËrtÉ™nt/', partOfSpeech: 'adjective' },
      'understand': { pronunciation: '/ËŒÊŒndÉ™rËˆstÃ¦nd/', partOfSpeech: 'verb' },
      'develop': { pronunciation: '/dÉªËˆvelÉ™p/', partOfSpeech: 'verb' },
      'different': { pronunciation: '/ËˆdÉªfÉ™rÉ™nt/', partOfSpeech: 'adjective' },
      'available': { pronunciation: '/É™ËˆveÉªlÉ™bÉ™l/', partOfSpeech: 'adjective' },
      'necessary': { pronunciation: '/ËˆnesÉ™seri/', partOfSpeech: 'adjective' },
      'possible': { pronunciation: '/ËˆpÉ‘ËsÉ™bÉ™l/', partOfSpeech: 'adjective' },
      'environment': { pronunciation: '/ÉªnËˆvaÉªrÉ™nmÉ™nt/', partOfSpeech: 'noun' },
      'knowledge': { pronunciation: '/ËˆnÉ‘ËlÉªdÊ’/', partOfSpeech: 'noun' },
      'experience': { pronunciation: '/ÉªkËˆspÉªriÉ™ns/', partOfSpeech: 'noun' }
    };

    // HÃ m láº¥y dá»¯ liá»‡u tá»« Dictionary API vá»›i nhiá»u fallback
    async function fetchWordData(word) {
      const wordLower = word.toLowerCase();
      
      // Kiá»ƒm tra cache trÆ°á»›c
      if (wordDataCache[wordLower]) {
        return wordDataCache[wordLower];
      }

      // Kiá»ƒm tra dá»¯ liá»‡u cÃ³ sáºµn trÆ°á»›c
      if (enhancedWordData[wordLower]) {
        const data = enhancedWordData[wordLower];
        wordDataCache[wordLower] = data;
        return data;
      }

      // Thá»­ gá»i API vá»›i timeout vÃ  retry
      const apiUrls = [
        `https://api.dictionaryapi.dev/api/v2/entries/en/${wordLower}`,
        `https://api.dictionaryapi.dev/api/v2/entries/en_US/${wordLower}`
      ];

      for (const apiUrl of apiUrls) {
        try {
          // showApiStatus('Äang táº£i phiÃªn Ã¢m...', 'loading');
            
          // Táº¡o AbortController Ä‘á»ƒ timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout

          const response = await fetch(apiUrl, {
            signal: controller.signal,
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            }
          });

          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          
          if (data && data.length > 0) {
            const entry = data[0];
            
            // Láº¥y phiÃªn Ã¢m
            let pronunciation = '';
            if (entry.phonetics && entry.phonetics.length > 0) {
              // TÃ¬m phiÃªn Ã¢m cÃ³ text
              const phoneticWithText = entry.phonetics.find(p => p.text && p.text.trim());
              if (phoneticWithText) {
                pronunciation = phoneticWithText.text;
              } else if (entry.phonetics[0].text) {
                pronunciation = entry.phonetics[0].text;
              }
            }
            
            // Láº¥y tá»« loáº¡i
            let partOfSpeech = 'noun';
            if (entry.meanings && entry.meanings.length > 0) {
              partOfSpeech = entry.meanings[0].partOfSpeech || 'noun';
            }
            
            // Láº¥y Ã¢m thanh phÃ¡t Ã¢m
            let audioUrl = '';
            if (entry.phonetics && entry.phonetics.length > 0) {
              const phoneticWithAudio = entry.phonetics.find(p => p.audio && p.audio.trim());
              if (phoneticWithAudio) {
                audioUrl = phoneticWithAudio.audio;
              }
            }

            const wordData = {
              pronunciation: pronunciation || `/${wordLower}/`,
              partOfSpeech: partOfSpeech,
              audioUrl: audioUrl
            };

            // LÆ°u vÃ o cache
            wordDataCache[wordLower] = wordData;
            // showApiStatus('Táº£i phiÃªn Ã¢m thÃ nh cÃ´ng!', 'success');
            
            return wordData;
          }
        } catch (error) {
          console.error(`Lá»—i khi gá»i API ${apiUrl}:`, error);
          
          if (error.name === 'AbortError') {
            showApiStatus('Timeout - Sá»­ dá»¥ng dá»¯ liá»‡u offline', 'error');
          } else {
            showApiStatus('Lá»—i máº¡ng - Sá»­ dá»¥ng dá»¯ liá»‡u offline', 'error');
          }
          
          // Thá»­ API tiáº¿p theo
          continue;
        }
      }

      // Fallback data vá»›i phiÃªn Ã¢m Æ°á»›c tÃ­nh
      const fallbackData = {
        pronunciation: generateFallbackPronunciation(wordLower),
        partOfSpeech: guessPartOfSpeech(wordLower),
        audioUrl: ''
      };
      
      wordDataCache[wordLower] = fallbackData;
      return fallbackData;
    }

    // HÃ m táº¡o phiÃªn Ã¢m Æ°á»›c tÃ­nh Ä‘Æ¡n giáº£n
    function generateFallbackPronunciation(word) {
      // Má»™t sá»‘ quy táº¯c phiÃªn Ã¢m cÆ¡ báº£n
      const rules = {
        'tion': 'ÊƒÉ™n',
        'sion': 'ÊƒÉ™n',
        'ough': 'ÊŒf',
        'ight': 'aÉªt',
        'ph': 'f',
        'th': 'Î¸',
        'ch': 'tÊƒ',
        'sh': 'Êƒ',
        'ing': 'ÉªÅ‹',
        'ed': 'd',
        'ly': 'li'
      };
      
      let pronunciation = word.toLowerCase();
      
      // Ãp dá»¥ng cÃ¡c quy táº¯c
      for (const [pattern, replacement] of Object.entries(rules)) {
        pronunciation = pronunciation.replace(new RegExp(pattern, 'g'), replacement);
      }
      
      return `/${pronunciation}/`;
    }

    // HÃ m Ä‘oÃ¡n tá»« loáº¡i dá»±a trÃªn háº­u tá»‘
    function guessPartOfSpeech(word) {
      const adjSuffixes = ['able', 'ible', 'al', 'ful', 'less', 'ous', 'ive', 'ic'];
      const nounSuffixes = ['tion', 'sion', 'ment', 'ness', 'ity', 'er', 'or', 'ist'];
      const verbSuffixes = ['ate', 'ize', 'ify', 'en'];
      const advSuffixes = ['ly'];
      
      for (const suffix of adjSuffixes) {
        if (word.endsWith(suffix)) return 'adjective';
      }
      
      for (const suffix of nounSuffixes) {
        if (word.endsWith(suffix)) return 'noun';
      }
      
      for (const suffix of verbSuffixes) {
        if (word.endsWith(suffix)) return 'verb';
      }
      
      for (const suffix of advSuffixes) {
        if (word.endsWith(suffix)) return 'adverb';
      }
      
      return 'noun'; // Default
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function updateProgress() {
      const progress = ((currentIndex + 1) / vocabulary.length) * 100;
      progressFillEl.style.width = progress + '%';
    }

    async function loadCard(index) {
      const word = vocabulary[index];
      
      // Hiá»ƒn thá»‹ tá»« ngay láº­p tá»©c
      wordEl.textContent = word.word;
      pronunciationEl.textContent = 'Äang táº£i...';
      pronunciationEl.className = 'pronunciation loading';
      wordTypeEl.textContent = '';
      wordTypeEl.style.display = 'none';
      
      meaningEl.textContent = flipped ? word.meaning : '';
      exampleEl.textContent = flipped ? word.example : '';

      // Cáº­p nháº­t tráº¡ng thÃ¡i há»c
      updateLearnedStatus(word.word);
      updateProgress();

      // Láº¥y thÃ´ng tin tá»« API
      try {
        const wordData = await fetchWordData(word.word);
        
        // Hiá»ƒn thá»‹ phiÃªn Ã¢m
        pronunciationEl.textContent = wordData.pronunciation;
        pronunciationEl.className = 'pronunciation';
        
        // LÆ°u URL audio Ä‘á»ƒ sá»­ dá»¥ng khi phÃ¡t Ã¢m
        if (wordData.audioUrl) {
          word.audioUrl = wordData.audioUrl;
        }

        // Hiá»ƒn thá»‹ tá»« loáº¡i
        if (wordData.partOfSpeech && partOfSpeechMap[wordData.partOfSpeech]) {
          const posInfo = partOfSpeechMap[wordData.partOfSpeech];
          wordTypeEl.textContent = `(${posInfo.short})`;
          wordTypeEl.className = `word-type ${posInfo.class}`;
          wordTypeEl.title = posInfo.name;
          wordTypeEl.style.display = 'inline-block';
        } else {
          wordTypeEl.textContent = '(n)';
          wordTypeEl.className = 'word-type n';
          wordTypeEl.title = 'Danh tá»«';
          wordTypeEl.style.display = 'inline-block';
        }

      } catch (error) {
        console.error('Lá»—i khi táº£i card:', error);
        pronunciationEl.textContent = `/${word.word}/`;
        pronunciationEl.className = 'pronunciation error';
        
        wordTypeEl.textContent = '(n)';
        wordTypeEl.className = 'word-type n';
        wordTypeEl.title = 'Danh tá»«';
        wordTypeEl.style.display = 'inline-block';
      }
    }

    function updateLearnedStatus(word) {
      const learned = JSON.parse(localStorage.getItem("learnedWords") || "[]");
      const isLearned = learned.includes(word);
      
      learnBtnEl.textContent = isLearned ? "âœ“" : "â—‹";
      learnBtnEl.className = isLearned ? "control-btn learned" : "control-btn";
      
      if (isLearned) {
        statusEl.textContent = "âœ… Báº¡n Ä‘Ã£ há»c tá»« nÃ y";
      } else {
        statusEl.textContent = "ğŸ”” Báº¡n chÆ°a há»c tá»« nÃ y";
      }
    }

    function flipCard(event) {
      // KhÃ´ng flip náº¿u click vÃ o control buttons
      if (event && event.target.closest('.card-controls')) {
        return;
      }
      
      if (!isDragging) {
        flipped = !flipped;
        loadCard(currentIndex);
      }
    }

    function toggleLearned(event) {
      event.stopPropagation();
      const word = vocabulary[currentIndex].word;
      let learned = JSON.parse(localStorage.getItem("learnedWords") || "[]");
      
      if (learned.includes(word)) {
        learned = learned.filter(w => w !== word);
      } else {
        learned.push(word);
      }
      
      localStorage.setItem("learnedWords", JSON.stringify(learned));
      updateLearnedStatus(word);
    }

    function copyWord(event) {
      event.stopPropagation();
      const word = vocabulary[currentIndex];
      const textToCopy = word.word;
      
      navigator.clipboard.writeText(textToCopy).then(() => {
        const copyBtn = event.target;
        const originalText = copyBtn.textContent;
        copyBtn.textContent = "âœ“";
        copyBtn.style.background = "linear-gradient(145deg, #28a745, #20c997)";
        
        setTimeout(() => {
          copyBtn.textContent = originalText;
          copyBtn.style.background = "linear-gradient(145deg, #007acc, #0056b3)";
        }, 1000);
      }).catch(err => {
        console.error('KhÃ´ng thá»ƒ sao chÃ©p:', err);
      });
    }

    function playPronunciation(event) {
      event.stopPropagation();
      
      const word = vocabulary[currentIndex];
      
      // Thá»­ phÃ¡t Ã¢m tá»« API trÆ°á»›c (náº¿u cÃ³)
      if (word.audioUrl) {
        try {
          // Dá»«ng audio hiá»‡n táº¡i náº¿u cÃ³
          if (currentAudio) {
            currentAudio.pause();
            currentAudio.currentTime = 0;
          }
          
          currentAudio = new Audio(word.audioUrl);
          currentAudio.play().catch(err => {
            console.log('KhÃ´ng thá»ƒ phÃ¡t Ã¢m tá»« API, chuyá»ƒn sang Web Speech API');
            playWithSpeechAPI(word.word);
          });
          return;
        } catch (error) {
          console.log('Lá»—i khi phÃ¡t Ã¢m tá»« API:', error);
        }
      }
      
      // Fallback sang Web Speech API
      playWithSpeechAPI(word.word);
    }

    function playWithSpeechAPI(word) {
      if ('speechSynthesis' in window) {
        // Dá»«ng phÃ¡t Ã¢m hiá»‡n táº¡i náº¿u cÃ³
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = 'en-US';
        utterance.rate = 0.8;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        speechSynthesis.speak(utterance);
      } else {
        console.log('TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ phÃ¡t Ã¢m');
      }
    }

    function nextCard() {
      if (vocabulary.length === 0) return;
      currentIndex = (currentIndex + 1) % vocabulary.length;
      flipped = false;
      loadCard(currentIndex);
    }

    function prevCard() {
      if (vocabulary.length === 0) return;
      currentIndex = (currentIndex - 1 + vocabulary.length) % vocabulary.length;
      flipped = false;
      loadCard(currentIndex);
    }

    // Touch handlers
    function handleTouchStart(event) {
      startX = event.touches[0].clientX;
      startY = event.touches[0].clientY;
      currentX = startX;
      currentY = startY;
      isDragging = false;
      cardEl = event.target.closest('.card');
    }

    function handleTouchMove(event) {
      if (!cardEl) return;
      
      event.preventDefault();
      currentX = event.touches[0].clientX;
      currentY = event.touches[0].clientY;
      
      const diffX = currentX - startX;
      const diffY = currentY - startY;
      
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
        isDragging = true;
        cardEl.style.transform = `translateX(${diffX}px) rotate(${diffX * 0.1}deg)`;
        cardEl.style.opacity = 1 - Math.abs(diffX) / 300;
      }
    }

    function handleTouchEnd(event) {
      if (!cardEl) return;
      
      const diffX = currentX - startX;
      const threshold = 80;
      
      if (Math.abs(diffX) > threshold) {
        if (diffX > 0) {
          cardEl.style.transform = 'translateX(100%) rotate(20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            prevCard();
            resetCardPosition();
          }, 300);
        } else {
          cardEl.style.transform = 'translateX(-100%) rotate(-20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            nextCard();
            resetCardPosition();
          }, 300);
        }
      } else {
        resetCardPosition();
      }
      
      isDragging = false;
      cardEl = null;
    }

    function resetCardPosition() {
      const card = document.getElementById('card');
      card.style.transform = 'translateX(0) rotate(0deg)';
      card.style.opacity = '1';
    }

    // Mouse events for desktop
    let mouseDown = false;
    let startMouseX = 0;
    let startMouseY = 0;

    document.getElementById('card').addEventListener('mousedown', (e) => {
      mouseDown = true;
      startMouseX = e.clientX;
      startMouseY = e.clientY;
      isDragging = false;
      cardEl = e.target.closest('.card');
    });

    document.addEventListener('mousemove', (e) => {
      if (!mouseDown || !cardEl) return;
      
      const diffX = e.clientX - startMouseX;
      const diffY = e.clientY - startMouseY;
      
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
        isDragging = true;
        cardEl.style.transform = `translateX(${diffX}px) rotate(${diffX * 0.1}deg)`;
        cardEl.style.opacity = 1 - Math.abs(diffX) / 300;
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (!mouseDown || !cardEl) return;
      
      const diffX = e.clientX - startMouseX;
      const threshold = 80;
      
      if (Math.abs(diffX) > threshold) {
        if (diffX > 0) {
          cardEl.style.transform = 'translateX(100%) rotate(20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            prevCard();
            resetCardPosition();
          }, 300);
        } else {
          cardEl.style.transform = 'translateX(-100%) rotate(-20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            nextCard();
            resetCardPosition();
          }, 300);
        }
      } else {
        resetCardPosition();
      }
      
      mouseDown = false;
      isDragging = false;
      cardEl = null;
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        prevCard();
      } else if (e.key === 'ArrowRight') {
        nextCard();
      } else if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        flipCard();
      }
    });

    // Sample data
    const sampleData = [
      {
        word: "intend",
        meaning: "CÃ³ Ã½ Ä‘á»‹nh, dá»± Ä‘á»‹nh",
        example: "I intend to finish this project by tomorrow."
      },
      {
        word: "serendipity",
        meaning: "Sá»± tÃ¬nh cá» may máº¯n",
        example: "Finding this book was pure serendipity."
      },
      {
        word: "ephemeral",
        meaning: "Táº¡m thá»i, phÃ¹ du",
        example: "The beauty of cherry blossoms is ephemeral."
      },
      {
        word: "ubiquitous",
        meaning: "CÃ³ máº·t kháº¯p nÆ¡i",
        example: "Smartphones are ubiquitous in modern society."
      },
      {
        word: "mellifluous",
        meaning: "Ngá»t ngÃ o, du dÆ°Æ¡ng",
        example: "Her mellifluous voice captivated the audience."
      },
      {
        word: "quintessential",
        meaning: "Äiá»ƒn hÃ¬nh, tinh tÃºy",
        example: "This painting is quintessential of the Renaissance period."
      },
      {
        word: "quickly",
        meaning: "Má»™t cÃ¡ch nhanh chÃ³ng",
        example: "She ran quickly to catch the bus."
      },
      {
        word: "beautiful",
        meaning: "Äáº¹p, xinh Ä‘áº¹p",
        example: "The sunset was beautiful tonight."
      },
      {
        word: "adventure",
        meaning: "Cuá»™c phiÃªu lÆ°u, máº¡o hiá»ƒm",
        example: "Their trip to the mountains was quite an adventure."
      },
      {
        word: "mysterious",
        meaning: "BÃ­ áº©n, khÃ³ hiá»ƒu",
        example: "The old mansion had a mysterious atmosphere."
      }
    ];

    // Initialize with sample data
    vocabulary = sampleData;
    shuffle(vocabulary);
    currentIndex = 0;
    loadCard(currentIndex);

    // Try to fetch data.json, fall back to sample data if not available
    fetch("data.json")
      .then(res => res.json())
      .then(data => {
        vocabulary = data;
        shuffle(vocabulary);
        currentIndex = 0;
        loadCard(currentIndex);
      })
      .catch(err => {
        console.log("Sá»­ dá»¥ng dá»¯ liá»‡u máº«u vÃ¬ khÃ´ng tÃ¬m tháº¥y data.json");
        // Keep using sample data
      });
  </script>
</body>
</html>