<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flashcard</title>
 <link rel="stylesheet" href="main.css">
</head>

<body>
  <h1>üí° T·ª´ v·ª±ng m·ªói ng√†y</h1>

  <div class="progress-bar">
    <div class="progress-fill" id="progressFill"></div>
  </div>

  <div class="card-container">
    <div class="card" id="card" ontouchstart="handleTouchStart(event)" ontouchmove="handleTouchMove(event)" ontouchend="handleTouchEnd(event)" onclick="flipCard(event)">
      <div class="card-controls">
        <button class="control-btn" id="learnBtn" onclick="toggleLearned(event)" title="ƒê√°nh d·∫•u ƒë√£ h·ªçc">‚óã</button>
        <button class="control-btn copy" onclick="copyWord(event)" title="Sao ch√©p t·ª´">üìã</button>
        <button class="control-btn sound" onclick="playPronunciation(event)" title="Ph√°t √¢m">üîä</button>
      </div>
      <div class="word-line">
        <div class="word" id="word">ƒêang t·∫£i...</div>
        <div class="pronunciation" id="pronunciation"></div>
        <div class="word-type" id="wordType"></div>
      </div>
      <div class="meaning" id="meaning"></div>
      <div class="example" id="example"></div>
    </div>
  </div>

  <div class="status" id="status"></div>
  <div class="api-status" id="apiStatus" style="display: none;"></div>

  <script>
    let vocabulary = [];
    let currentIndex = 0;
    let flipped = false;
    let currentAudio = null;
    let wordDataCache = {};

    // Touch/swipe variables
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let isDragging = false;
    let cardEl = null;

    const wordEl = document.getElementById("word");
    const pronunciationEl = document.getElementById("pronunciation");
    const meaningEl = document.getElementById("meaning");
    const exampleEl = document.getElementById("example");
    const statusEl = document.getElementById("status");
    const wordTypeEl = document.getElementById("wordType");
    const learnBtnEl = document.getElementById("learnBtn");
    const progressFillEl = document.getElementById("progressFill");
    const apiStatusEl = document.getElementById("apiStatus");

    // Mapping cho t·ª´ lo·∫°i
    const partOfSpeechMap = {
      'noun': { short: 'n', name: 'Danh t·ª´', class: 'n' },
      'verb': { short: 'v', name: 'ƒê·ªông t·ª´', class: 'v' },
      'adjective': { short: 'adj', name: 'T√≠nh t·ª´', class: 'adj' },
      'adverb': { short: 'adv', name: 'Tr·∫°ng t·ª´', class: 'adv' },
      'preposition': { short: 'prep', name: 'Gi·ªõi t·ª´', class: 'prep' },
      'conjunction': { short: 'conj', name: 'Li√™n t·ª´', class: 'conj' },
      'interjection': { short: 'interj', name: 'Th√°n t·ª´', class: 'interj' },
      'pronoun': { short: 'pron', name: 'ƒê·∫°i t·ª´', class: 'pron' },
      'determiner': { short: 'det', name: 'T·ª´ h·∫°n ƒë·ªãnh', class: 'det' },
      'exclamation': { short: 'interj', name: 'Th√°n t·ª´', class: 'interj' }
    };

    // H√†m hi·ªÉn th·ªã tr·∫°ng th√°i API
    function showApiStatus(message, type) {
      apiStatusEl.textContent = message;
      apiStatusEl.className = `api-status ${type}`;
      apiStatusEl.style.display = 'block';
      
      setTimeout(() => {
        apiStatusEl.style.display = 'none';
      }, 3000);
    }

    // Enhanced word data v·ªõi phi√™n √¢m c√≥ s·∫µn
    const enhancedWordData = {
      'intend': { pronunciation: '/…™nÀàtend/', partOfSpeech: 'verb' },
      'serendipity': { pronunciation: '/Àås…õr…ônÀàd…™p…™ti/', partOfSpeech: 'noun' },
      'ephemeral': { pronunciation: '/…™Ààf…õm…ôr…ôl/', partOfSpeech: 'adjective' },
      'ubiquitous': { pronunciation: '/juÀêÀàb…™kw…™t…ôs/', partOfSpeech: 'adjective' },
      'mellifluous': { pronunciation: '/m…ôÀàl…™flu…ôs/', partOfSpeech: 'adjective' },
      'quintessential': { pronunciation: '/Àåkw…™nt…™Ààs…õn É…ôl/', partOfSpeech: 'adjective' },
      'quickly': { pronunciation: '/Ààkw…™kli/', partOfSpeech: 'adverb' },
      'beautiful': { pronunciation: '/ÀàbjuÀêt…™f…ôl/', partOfSpeech: 'adjective' },
      'adventure': { pronunciation: '/…ôdÀàvent É…ôr/', partOfSpeech: 'noun' },
      'mysterious': { pronunciation: '/m…™Ààst…™…ôri…ôs/', partOfSpeech: 'adjective' },
      'important': { pronunciation: '/…™mÀàp…îÀêrt…ônt/', partOfSpeech: 'adjective' },
      'understand': { pronunciation: '/Àå ånd…ôrÀàst√¶nd/', partOfSpeech: 'verb' },
      'develop': { pronunciation: '/d…™Ààvel…ôp/', partOfSpeech: 'verb' },
      'different': { pronunciation: '/Ààd…™f…ôr…ônt/', partOfSpeech: 'adjective' },
      'available': { pronunciation: '/…ôÀàve…™l…ôb…ôl/', partOfSpeech: 'adjective' },
      'necessary': { pronunciation: '/Àànes…ôseri/', partOfSpeech: 'adjective' },
      'possible': { pronunciation: '/Ààp…ëÀês…ôb…ôl/', partOfSpeech: 'adjective' },
      'environment': { pronunciation: '/…™nÀàva…™r…ônm…ônt/', partOfSpeech: 'noun' },
      'knowledge': { pronunciation: '/Ààn…ëÀêl…™d í/', partOfSpeech: 'noun' },
      'experience': { pronunciation: '/…™kÀàsp…™ri…ôns/', partOfSpeech: 'noun' }
    };

    // H√†m l·∫•y d·ªØ li·ªáu t·ª´ Dictionary API v·ªõi nhi·ªÅu fallback
    async function fetchWordData(word) {
      const wordLower = word.toLowerCase();
      
      // Ki·ªÉm tra cache tr∆∞·ªõc
      if (wordDataCache[wordLower]) {
        return wordDataCache[wordLower];
      }

      // Ki·ªÉm tra d·ªØ li·ªáu c√≥ s·∫µn tr∆∞·ªõc
      if (enhancedWordData[wordLower]) {
        const data = enhancedWordData[wordLower];
        wordDataCache[wordLower] = data;
        return data;
      }

      // Th·ª≠ g·ªçi API v·ªõi timeout v√† retry
      const apiUrls = [
        `https://api.dictionaryapi.dev/api/v2/entries/en/${wordLower}`,
        `https://api.dictionaryapi.dev/api/v2/entries/en_US/${wordLower}`
      ];

      for (const apiUrl of apiUrls) {
        try {
          // showApiStatus('ƒêang t·∫£i phi√™n √¢m...', 'loading');
            
          // T·∫°o AbortController ƒë·ªÉ timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5s timeout

          const response = await fetch(apiUrl, {
            signal: controller.signal,
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            }
          });

          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          
          if (data && data.length > 0) {
            const entry = data[0];
            
            // L·∫•y phi√™n √¢m
            let pronunciation = '';
            if (entry.phonetics && entry.phonetics.length > 0) {
              // T√¨m phi√™n √¢m c√≥ text
              const phoneticWithText = entry.phonetics.find(p => p.text && p.text.trim());
              if (phoneticWithText) {
                pronunciation = phoneticWithText.text;
              } else if (entry.phonetics[0].text) {
                pronunciation = entry.phonetics[0].text;
              }
            }
            
            // L·∫•y t·ª´ lo·∫°i
            let partOfSpeech = 'noun';
            if (entry.meanings && entry.meanings.length > 0) {
              partOfSpeech = entry.meanings[0].partOfSpeech || 'noun';
            }
            
            // L·∫•y √¢m thanh ph√°t √¢m
            let audioUrl = '';
            if (entry.phonetics && entry.phonetics.length > 0) {
              const phoneticWithAudio = entry.phonetics.find(p => p.audio && p.audio.trim());
              if (phoneticWithAudio) {
                audioUrl = phoneticWithAudio.audio;
              }
            }

            const wordData = {
              pronunciation: pronunciation || `/${wordLower}/`,
              partOfSpeech: partOfSpeech,
              audioUrl: audioUrl
            };

            // L∆∞u v√†o cache
            wordDataCache[wordLower] = wordData;
            // showApiStatus('T·∫£i phi√™n √¢m th√†nh c√¥ng!', 'success');
            
            return wordData;
          }
        } catch (error) {
          console.error(`L·ªói khi g·ªçi API ${apiUrl}:`, error);
          
          if (error.name === 'AbortError') {
            showApiStatus('Timeout - S·ª≠ d·ª•ng d·ªØ li·ªáu offline', 'error');
          } else {
            showApiStatus('L·ªói m·∫°ng - S·ª≠ d·ª•ng d·ªØ li·ªáu offline', 'error');
          }
          
          // Th·ª≠ API ti·∫øp theo
          continue;
        }
      }

      // Fallback data v·ªõi phi√™n √¢m ∆∞·ªõc t√≠nh
      const fallbackData = {
        pronunciation: generateFallbackPronunciation(wordLower),
        partOfSpeech: guessPartOfSpeech(wordLower),
        audioUrl: ''
      };
      
      wordDataCache[wordLower] = fallbackData;
      return fallbackData;
    }

    // H√†m t·∫°o phi√™n √¢m ∆∞·ªõc t√≠nh ƒë∆°n gi·∫£n
    function generateFallbackPronunciation(word) {
      // M·ªôt s·ªë quy t·∫Øc phi√™n √¢m c∆° b·∫£n
      const rules = {
        'tion': ' É…ôn',
        'sion': ' É…ôn',
        'ough': ' åf',
        'ight': 'a…™t',
        'ph': 'f',
        'th': 'Œ∏',
        'ch': 't É',
        'sh': ' É',
        'ing': '…™≈ã',
        'ed': 'd',
        'ly': 'li'
      };
      
      let pronunciation = word.toLowerCase();
      
      // √Åp d·ª•ng c√°c quy t·∫Øc
      for (const [pattern, replacement] of Object.entries(rules)) {
        pronunciation = pronunciation.replace(new RegExp(pattern, 'g'), replacement);
      }
      
      return `/${pronunciation}/`;
    }

    // H√†m ƒëo√°n t·ª´ lo·∫°i d·ª±a tr√™n h·∫≠u t·ªë
    function guessPartOfSpeech(word) {
      const adjSuffixes = ['able', 'ible', 'al', 'ful', 'less', 'ous', 'ive', 'ic'];
      const nounSuffixes = ['tion', 'sion', 'ment', 'ness', 'ity', 'er', 'or', 'ist'];
      const verbSuffixes = ['ate', 'ize', 'ify', 'en'];
      const advSuffixes = ['ly'];
      
      for (const suffix of adjSuffixes) {
        if (word.endsWith(suffix)) return 'adjective';
      }
      
      for (const suffix of nounSuffixes) {
        if (word.endsWith(suffix)) return 'noun';
      }
      
      for (const suffix of verbSuffixes) {
        if (word.endsWith(suffix)) return 'verb';
      }
      
      for (const suffix of advSuffixes) {
        if (word.endsWith(suffix)) return 'adverb';
      }
      
      return 'noun'; // Default
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function updateProgress() {
      const progress = ((currentIndex + 1) / vocabulary.length) * 100;
      progressFillEl.style.width = progress + '%';
    }

    async function loadCard(index) {
      const word = vocabulary[index];
      
      // Hi·ªÉn th·ªã t·ª´ ngay l·∫≠p t·ª©c
      wordEl.textContent = word.word;
      pronunciationEl.textContent = 'ƒêang t·∫£i...';
      pronunciationEl.className = 'pronunciation loading';
      wordTypeEl.textContent = '';
      wordTypeEl.style.display = 'none';
      
      meaningEl.textContent = flipped ? word.meaning : '';
      exampleEl.textContent = flipped ? word.example : '';

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i h·ªçc
      updateLearnedStatus(word.word);
      updateProgress();

      // L·∫•y th√¥ng tin t·ª´ API
      try {
        const wordData = await fetchWordData(word.word);
        
        // Hi·ªÉn th·ªã phi√™n √¢m
        pronunciationEl.textContent = wordData.pronunciation;
        pronunciationEl.className = 'pronunciation';
        
        // L∆∞u URL audio ƒë·ªÉ s·ª≠ d·ª•ng khi ph√°t √¢m
        if (wordData.audioUrl) {
          word.audioUrl = wordData.audioUrl;
        }

        // Hi·ªÉn th·ªã t·ª´ lo·∫°i
        if (wordData.partOfSpeech && partOfSpeechMap[wordData.partOfSpeech]) {
          const posInfo = partOfSpeechMap[wordData.partOfSpeech];
          wordTypeEl.textContent = `(${posInfo.short})`;
          wordTypeEl.className = `word-type ${posInfo.class}`;
          wordTypeEl.title = posInfo.name;
          wordTypeEl.style.display = 'inline-block';
        } else {
          wordTypeEl.textContent = '(n)';
          wordTypeEl.className = 'word-type n';
          wordTypeEl.title = 'Danh t·ª´';
          wordTypeEl.style.display = 'inline-block';
        }

      } catch (error) {
        console.error('L·ªói khi t·∫£i card:', error);
        pronunciationEl.textContent = `/${word.word}/`;
        pronunciationEl.className = 'pronunciation error';
        
        wordTypeEl.textContent = '(n)';
        wordTypeEl.className = 'word-type n';
        wordTypeEl.title = 'Danh t·ª´';
        wordTypeEl.style.display = 'inline-block';
      }
    }

    function updateLearnedStatus(word) {
      const learned = JSON.parse(localStorage.getItem("learnedWords") || "[]");
      const isLearned = learned.includes(word);
      
      learnBtnEl.textContent = isLearned ? "‚úì" : "‚óã";
      learnBtnEl.className = isLearned ? "control-btn learned" : "control-btn";
      
      if (isLearned) {
        statusEl.textContent = "‚úÖ B·∫°n ƒë√£ h·ªçc t·ª´ n√†y";
      } else {
        statusEl.textContent = "üîî B·∫°n ch∆∞a h·ªçc t·ª´ n√†y";
      }
    }

    function flipCard(event) {
      // Kh√¥ng flip n·∫øu click v√†o control buttons
      if (event && event.target.closest('.card-controls')) {
        return;
      }
      
      if (!isDragging) {
        flipped = !flipped;
        loadCard(currentIndex);
      }
    }

    function toggleLearned(event) {
      event.stopPropagation();
      const word = vocabulary[currentIndex].word;
      let learned = JSON.parse(localStorage.getItem("learnedWords") || "[]");
      
      if (learned.includes(word)) {
        learned = learned.filter(w => w !== word);
      } else {
        learned.push(word);
      }
      
      localStorage.setItem("learnedWords", JSON.stringify(learned));
      updateLearnedStatus(word);
    }

    function copyWord(event) {
      event.stopPropagation();
      const word = vocabulary[currentIndex];
      const textToCopy = word.word;
      
      navigator.clipboard.writeText(textToCopy).then(() => {
        const copyBtn = event.target;
        const originalText = copyBtn.textContent;
        copyBtn.textContent = "‚úì";
        copyBtn.style.background = "linear-gradient(145deg, #28a745, #20c997)";
        
        setTimeout(() => {
          copyBtn.textContent = originalText;
          copyBtn.style.background = "linear-gradient(145deg, #007acc, #0056b3)";
        }, 1000);
      }).catch(err => {
        console.error('Kh√¥ng th·ªÉ sao ch√©p:', err);
      });
    }

    function playPronunciation(event) {
      event.stopPropagation();
      
      const word = vocabulary[currentIndex];
      
      // Th·ª≠ ph√°t √¢m t·ª´ API tr∆∞·ªõc (n·∫øu c√≥)
      if (word.audioUrl) {
        try {
          // D·ª´ng audio hi·ªán t·∫°i n·∫øu c√≥
          if (currentAudio) {
            currentAudio.pause();
            currentAudio.currentTime = 0;
          }
          
          currentAudio = new Audio(word.audioUrl);
          currentAudio.play().catch(err => {
            console.log('Kh√¥ng th·ªÉ ph√°t √¢m t·ª´ API, chuy·ªÉn sang Web Speech API');
            playWithSpeechAPI(word.word);
          });
          return;
        } catch (error) {
          console.log('L·ªói khi ph√°t √¢m t·ª´ API:', error);
        }
      }
      
      // Fallback sang Web Speech API
      playWithSpeechAPI(word.word);
    }

    function playWithSpeechAPI(word) {
      if ('speechSynthesis' in window) {
        // D·ª´ng ph√°t √¢m hi·ªán t·∫°i n·∫øu c√≥
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = 'en-US';
        utterance.rate = 0.8;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        speechSynthesis.speak(utterance);
      } else {
        console.log('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ph√°t √¢m');
      }
    }

    function nextCard() {
      if (vocabulary.length === 0) return;
      currentIndex = (currentIndex + 1) % vocabulary.length;
      flipped = false;
      loadCard(currentIndex);
    }

    function prevCard() {
      if (vocabulary.length === 0) return;
      currentIndex = (currentIndex - 1 + vocabulary.length) % vocabulary.length;
      flipped = false;
      loadCard(currentIndex);
    }

    // Touch handlers
    function handleTouchStart(event) {
      startX = event.touches[0].clientX;
      startY = event.touches[0].clientY;
      currentX = startX;
      currentY = startY;
      isDragging = false;
      cardEl = event.target.closest('.card');
    }

    function handleTouchMove(event) {
      if (!cardEl) return;
      
      event.preventDefault();
      currentX = event.touches[0].clientX;
      currentY = event.touches[0].clientY;
      
      const diffX = currentX - startX;
      const diffY = currentY - startY;
      
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
        isDragging = true;
        cardEl.style.transform = `translateX(${diffX}px) rotate(${diffX * 0.1}deg)`;
        cardEl.style.opacity = 1 - Math.abs(diffX) / 300;
      }
    }

    function handleTouchEnd(event) {
      if (!cardEl) return;
      
      const diffX = currentX - startX;
      const threshold = 80;
      
      if (Math.abs(diffX) > threshold) {
        if (diffX > 0) {
          cardEl.style.transform = 'translateX(100%) rotate(20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            prevCard();
            resetCardPosition();
          }, 300);
        } else {
          cardEl.style.transform = 'translateX(-100%) rotate(-20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            nextCard();
            resetCardPosition();
          }, 300);
        }
      } else {
        resetCardPosition();
      }
      
      isDragging = false;
      cardEl = null;
    }

    function resetCardPosition() {
      const card = document.getElementById('card');
      card.style.transform = 'translateX(0) rotate(0deg)';
      card.style.opacity = '1';
    }

    // Mouse events for desktop
    let mouseDown = false;
    let startMouseX = 0;
    let startMouseY = 0;

    document.getElementById('card').addEventListener('mousedown', (e) => {
      mouseDown = true;
      startMouseX = e.clientX;
      startMouseY = e.clientY;
      isDragging = false;
      cardEl = e.target.closest('.card');
    });

    document.addEventListener('mousemove', (e) => {
      if (!mouseDown || !cardEl) return;
      
      const diffX = e.clientX - startMouseX;
      const diffY = e.clientY - startMouseY;
      
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
        isDragging = true;
        cardEl.style.transform = `translateX(${diffX}px) rotate(${diffX * 0.1}deg)`;
        cardEl.style.opacity = 1 - Math.abs(diffX) / 300;
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (!mouseDown || !cardEl) return;
      
      const diffX = e.clientX - startMouseX;
      const threshold = 80;
      
      if (Math.abs(diffX) > threshold) {
        if (diffX > 0) {
          cardEl.style.transform = 'translateX(100%) rotate(20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            prevCard();
            resetCardPosition();
          }, 300);
        } else {
          cardEl.style.transform = 'translateX(-100%) rotate(-20deg)';
          cardEl.style.opacity = '0';
          setTimeout(() => {
            nextCard();
            resetCardPosition();
          }, 300);
        }
      } else {
        resetCardPosition();
      }
      
      mouseDown = false;
      isDragging = false;
      cardEl = null;
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        prevCard();
      } else if (e.key === 'ArrowRight') {
        nextCard();
      } else if (e.key === ' ' || e.key === 'Enter') {
        e.preventDefault();
        flipCard();
      }
    });

    // Sample data
    const sampleData = [
      {
        word: "intend",
        meaning: "C√≥ √Ω ƒë·ªãnh, d·ª± ƒë·ªãnh",
        example: "I intend to finish this project by tomorrow."
      },
      {
        word: "serendipity",
        meaning: "S·ª± t√¨nh c·ªù may m·∫Øn",
        example: "Finding this book was pure serendipity."
      },
      {
        word: "ephemeral",
        meaning: "T·∫°m th·ªùi, ph√π du",
        example: "The beauty of cherry blossoms is ephemeral."
      },
      {
        word: "ubiquitous",
        meaning: "C√≥ m·∫∑t kh·∫Øp n∆°i",
        example: "Smartphones are ubiquitous in modern society."
      },
      {
        word: "mellifluous",
        meaning: "Ng·ªçt ng√†o, du d∆∞∆°ng",
        example: "Her mellifluous voice captivated the audience."
      },
      {
        word: "quintessential",
        meaning: "ƒêi·ªÉn h√¨nh, tinh t√∫y",
        example: "This painting is quintessential of the Renaissance period."
      },
      {
        word: "quickly",
        meaning: "M·ªôt c√°ch nhanh ch√≥ng",
        example: "She ran quickly to catch the bus."
      },
      {
        word: "beautiful",
        meaning: "ƒê·∫πp, xinh ƒë·∫πp",
        example: "The sunset was beautiful tonight."
      },
      {
        word: "adventure",
        meaning: "Cu·ªôc phi√™u l∆∞u, m·∫°o hi·ªÉm",
        example: "Their trip to the mountains was quite an adventure."
      },
      {
        word: "mysterious",
        meaning: "B√≠ ·∫©n, kh√≥ hi·ªÉu",
        example: "The old mansion had a mysterious atmosphere."
      }
    ];

    // Initialize with sample data
    vocabulary = sampleData;
    shuffle(vocabulary);
    currentIndex = 0;
    loadCard(currentIndex);

    // Try to fetch data.json, fall back to sample data if not available
    fetch("data.json")
      .then(res => res.json())
      .then(data => {
        vocabulary = data;
        shuffle(vocabulary);
        currentIndex = 0;
        loadCard(currentIndex);
      })
      .catch(err => {
        console.log("S·ª≠ d·ª•ng d·ªØ li·ªáu m·∫´u v√¨ kh√¥ng t√¨m th·∫•y data.json");
        // Keep using sample data
      });
  </script>
</body>
</html>